package rabota;

import java.util.ArrayList;

//класс дерева узлов
public class Tree {

    public Node[] nodeArray;//массив узлов
    public ArrayList<Node[]> nodesList;//создадим список в который будем помещать узлы
    int sum;//счётчик созданных узлов
    int index;//порядковый номер узлов
    int children=0;//количество потомков
    int temp=0;//вспомогательная переменная
    int count;//вспомогательная переменная - индекс формируемого массива

    //метод формирования графа по правилу А
    public void creation_A(int n, int m){
    sum = 1; index = 1;
    nodesList = new ArrayList<>();
        //создаём первый узел
        Node root = new Node();
        root.child = (int) (Math.random() * (m + 1));//случайным образом определяем количество потомков
        if (root.child==0){//если потомков нет, то выходим из метода
            return;
        } else{
            //иначе присваиваем узлу номер, помещаем его в массив узлов и массив узлов помещаем в список масивов
            root.index = 1;//номер первого узла
            root.parent = 0;//номер его предка
            nodeArray = new Node[1];//создаём массив с 1 элементом
            nodeArray[0]= root;//помещаем первый узел в созданный массив
            nodesList.add(nodeArray);//помещаем массив с 1 узлом в список массивов
            children=root.child;//задаём количество потомком, необходимо для формирования массива потомков
        }
//создаём другие узлы графа
       do {
            Node[] tempArray = new Node[children];//создаём вспомогательный массив с заданным количеством потомков
            if(tempArray.length==0){return;}//если очередной массив не содержит элементов, то выходим из метода - достигнут
                                            //последний висячий узел, обрабатывать больше нечего
            count = 0;//вспомогательный счётчик
            for (int i = 0; i <= nodeArray.length - 1; i++) {//цикл перебора массива узлов
                if (sum==n){break;}//если достигнуто заданное число узлов - вход из метода
                for (int j = 0; j <= nodeArray[i].child - 1; j++) {//цикл перебора всех потомков узла массива
                    Node current = new Node();//создаём новый узел
                    index = index + 1;//инкремент индекса - номера узла по порядку
                    current.index = index;//присвоение номера узлу
                    current.parent = nodeArray[i].index;//присвоение номера предка узла
                    current.child = (int) (Math.random() * (m + 1));//получение количества потомков узла случайныи образом от 0 до m-1
                    temp = temp + current.child;//счётчик потомков всех узлов следующего уровня (нового массива)
                    tempArray[count] = current;//помещаем созданный узел в массив
                    count = count + 1;//инкремент индекса нового массива empArray
                    sum = sum + 1;//счётчик зоданных узлов
                    if (sum == n) {//если достигнуто заданное число, то выходим из цикла
                        break;
                    }
                }
            }
                children = temp;//общее число потомков для нового массива узлов
                nodeArray = tempArray;//присваение ссылки на вспомогательный массив основному массиву узлов
                nodesList.add(nodeArray);//заносим сформированный массив в список массивов
                temp = 0;//сбрасываем вспомогательную переменную
                if (sum == n) {//если достигнуто заданное количесто узлов выходим из метода
                    return;
                }
            }
            while (sum<=n);//условие продолжения цикла
    }
/////////////////////////////////////////////////////////////////////
    //метод формирования графа по правилу В
    public void creation_B(int n, int m) {
        sum = 1; index = 1;//переменны суммы всех узлов, номер узла
        nodesList = new ArrayList<>();//список массивов уровней графа (каждый уровень-массив содержит узлы)
        //создаём первый узел
        Node root = new Node();//верхний, корневой узел - всегда присутствует
        root.child = (int) (Math.random() * (m + 1));//случайным образом определяем количество потомков
        if (root.child==0){//если потомков нет, то выходим из метода
            return;
        } else{
            //иначе присваиваем узлу номер, помещаем его в массив узлов и массив узлов помещаем в список масивов
            root.index = 1;//номер первого узла
            root.parent = 0;//номер его предка
            nodeArray = new Node[1];//создаём массив с 1 элементом
            nodeArray[0]= root;//помещаем первый узел в созданный массив
            nodesList.add(nodeArray);//помещаем массив с 1 узлом в список массивов
            children=root.child;//задаём количество потомком, необходимо для формирования массива потомков
        }
//создаём другие узлы графа
        do {
            Node[] tempArray = new Node[children];//создаём вспомогательный массив с заданным количеством потомков
            if(tempArray.length==0){return;}//если очередной массив не содержит элементов, то выходим из метода - достигнут
            //последний висячий узел, обрабатывать больше нечего
            count = 0;//вспомогательный счётчик
            for (int i = 0; i <= nodeArray.length - 1; i++) {//цикл перебора массива узлов
               // if (sum>=n){break;}//если достигнуто заданное число узлов - вход из метода
                for (int j = 0; j <= nodeArray[i].child - 1; j++) {//цикл перебора всех потомков узла массива
                    Node current = new Node();//создаём новый узел
                    index = index + 1;//инкремент индекса - номера узла по порядку
                    current.index = index;//присвоение номера узлу
                    current.parent = nodeArray[i].index;//присвоение номера предка узла
                    current.child = (int) (Math.random() * (m + 1));//получение количества потомков узла случайныи образом от 0 до m-1
                    temp = temp + current.child;//счётчик потомков всех узлов следующего уровня (нового массива)
                    tempArray[count] = current;//помещаем созданный узел в массив
                    count = count + 1;//инкремент индекса нового массива empArray
                    sum = sum + 1;//счётчик зоданных узлов
                }
            }
            children = temp;//общее число потомков для нового массива узлов
            nodeArray = tempArray;//присваение ссылки на вспомогательный массив основному массиву узлов
            //nodesList.add(nodeArray);//заносим сформированный массив в список массивов
            temp = 0;//сбрасываем вспомогательную переменную
            if (sum >= n) {//если достигнуто заданное количесто узлов обнуляем всех потомков узлов последенего массива - делаем висячими
                for(Node lastNodes: nodeArray){//перебираем последний массив
                    lastNodes.child=0;//и обнулем потомков для каждого из его узлов
                   // nodesList.set(nodesList.size()-1, nodeArray);//перезаписываем
                }
            }
            nodesList.add(nodeArray);//заносим сформированный массив в список массивов
        }
        while (sum<n);//условие продолжения цикла
    }
}
